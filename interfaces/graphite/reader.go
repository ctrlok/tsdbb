package graphite

import (
	"bufio"
	"io"
	"net/url"
	"os"
	"time"

	"github.com/ctrlok/tsdbb/interfaces"
)

// MetricByte is a
type MetricByte [4][2]byte

// Internal is tuple method for Metric interface
func (m *MetricByte) Internal() interface{} {
	return ""
}

type MetricInt struct {
	n1, n2, n3, n4 uint32
}

func (m *MetricInt) Internal() interface{} {
	return ""
}

// PregeneratedMetricsByte is a struct which contain Metric, and generated by TSDB.GenerateMetrics
type PregeneratedMetricsByte struct {
	metrics []MetricByte
	err     error
}

// Metric return metric or out of index error
func (p *PregeneratedMetricsByte) Metric(i int) (interfaces.Metric, error) {
	if i >= len(p.metrics) {
		return &MetricByte{}, p.err
	}
	return &p.metrics[i], nil
}

// PregeneratedMetricsInt is a struct which contain Metric, and generated by TSDB.GenerateMetrics
type PregeneratedMetricsInt struct {
	metrics [10000000]MetricInt
	err     error
}

// Metric return metric or out of index error
func (p *PregeneratedMetricsInt) Metric(i int) (interfaces.Metric, error) {
	if i >= len(p.metrics) {
		return &MetricInt{}, p.err
	}
	return &p.metrics[i], nil
}

// TSDB is a main generator of graphite Metric and Sender
type TSDB struct {
	PregeneratedType int
	GeneratorPrefix  []byte
	DevNull          bool
}

// GenerateMetrics is a method for create PregeneratedMetrics
func (t *TSDB) GenerateMetrics(i int) (p interfaces.PregeneratedMetrics) {
	switch t.PregeneratedType {
	case 0:
		p = t.generateMetricsInt(i)
	case 1:
		p = t.generateMetricsByte(i)
	}
	return p
}
func (t *TSDB) generateMetricsByte(i int) interfaces.PregeneratedMetrics {
	p := PregeneratedMetricsByte{}
	p.metrics = make([]MetricByte, i)
	for i := range p.metrics[0] {
		p.metrics[0][i][0] = 48
		p.metrics[0][i][1] = 48
	}
	for n := 1; n < i; n++ {
		var plus byte = 1
		for k := 3; k > -1; k-- {
			for m := 1; m > -1; m-- {
				if plus == 1 {
					if p.metrics[n-1][k][m] == 57 {
						p.metrics[n][k][m] = 48
					} else {
						p.metrics[n][k][m] = p.metrics[n-1][k][m] + plus
						plus = 0
					}
				} else {
					p.metrics[n][k][m] = p.metrics[n-1][k][m]
				}
			}
		}
	}

// 	var n1, n2, n3, n4 int = 0, 0, 0, 0
// 	for n := 0; n < i; n++ {
// 		// if n5 > 99 {
// 		// 	n5, n4 = 0, n4+1
// 		// }
// 		if n4 > 99 {
// 			n4, n3 = 0, n3+1
// 		}
// 		if n3 > 99 {
// 			n3, n2 = 0, n2+1
// 		}
// 		if n2 > 99 {
// 			n2, n1 = 0, n1+1
// 		}
// 		p.metrics[n][0] = itoa(n1)
// 		p.metrics[n][1] = itoa(n2)
// 		p.metrics[n][2] = itoa(n3)
// 		p.metrics[n][3] = itoa(n4)
// 		// p.metrics[n][4] = itoa(n5)
// 		n4++
// 	}
// 	return &p
// }

var bytesNum = [10]byte{48, 49, 50, 51, 52, 53, 54, 55, 56, 57}

func itoa(i int) (array [2]byte) {
	n := i / 10
	array[0] = bytesNum[n]
	array[1] = bytesNum[i-(n*10)]
	return
}

func (t *TSDB) generateMetricsInt(i int) interfaces.PregeneratedMetrics {
	p := PregeneratedMetricsInt{}
	var n1, n2, n3, n4 uint32 = 0, 0, 0, 0
	for n := 0; n < i; n++ {
		if n4 > 99 {
			n4, n3 = 0, n3+1
		}
		if n3 > 99 {
			n3, n2 = 0, n2+1
		}
		if n2 > 99 {
			n2, n1 = 0, n1+1
		}
		p.metrics[n].n1 = n1
		p.metrics[n].n2 = n2
		p.metrics[n].n3 = n3
		p.metrics[n].n4 = n4
		n4++
	}
	return &p
}

// NewSender will create new sender
func (t *TSDB) NewSender(uri *url.URL) (s interfaces.Sender, err error) {
	var sender SenderNull
	sender.f, _ = os.OpenFile("/tmp/metricTEst", os.O_RDWR, 0755)
	// sender.f = ioutil.Discard
	sender.w = bufio.NewWriter(sender.f)
	return &sender, nil
}

// SenderNull is a sender instance.
type SenderNull struct {
	f      io.Writer
	w      *bufio.Writer
	prefix []byte

	host string
}

// Send is a method for sending messages. Work only with internal Metric
func (s *SenderNull) Send(metric interfaces.Metric, t *time.Time) error {
	m := metric.(*MetricByte)
	s.w.Write(s.prefix)
	for i := 0; i < 4; i++ {
		s.w.WriteByte(46) // dot
		s.w.WriteByte(m[i][0])
		s.w.WriteByte(m[i][1])
		// s.w.Flush()
	}
	s.w.WriteByte(10) // newline
	return nil
}

// GetHost will return host of sender
func (s *SenderNull) GetHost() string {
	return s.host
}
